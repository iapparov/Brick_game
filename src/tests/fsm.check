#include "brick_game/tetris/fsm.h"
#include "brick_game/tetris/backend.h"
#include <check.h>


#suite fsmtests


#test user_input_1

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
ck_assert_int_eq(stats->state, MOVING);

#test user_input_2

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
userInput(get_signal(KEY_DOWN));
ck_assert_int_eq(stats->state, MOVING);

#test user_input_3

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
userInput(get_signal(KEY_LEFT));
ck_assert_int_eq(stats->state, MOVING);

#test user_input_4

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
userInput(get_signal(KEY_RIGHT));
ck_assert_int_eq(stats->state, MOVING);


#test user_input_5

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
userInput(get_signal('p'));
ck_assert_int_eq(stats->state, PAUSE);

#test user_input_6

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
userInput(get_signal(ESCAPE));
ck_assert_int_eq(stats->state, EXIT_STATE);

#test user_input_rotate_1

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
stats->current_block_type=1;
userInput(get_signal(SPACE_KEY));
ck_assert_int_eq(stats->state, MOVING);

#test user_input_rotate_2

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
stats->current_block_type=2;
userInput(get_signal(SPACE_KEY));
ck_assert_int_eq(stats->state, MOVING);

#test user_input_rotate_3

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
stats->current_block_type=3;
userInput(get_signal(SPACE_KEY));
ck_assert_int_eq(stats->state, MOVING);

#test user_input_rotate_4

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
stats->current_block_type=4;
userInput(get_signal(SPACE_KEY));
ck_assert_int_eq(stats->state, MOVING);

#test user_input_rotate_5

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
stats->current_block_type=5;
userInput(get_signal(SPACE_KEY));
ck_assert_int_eq(stats->state, MOVING);

#test user_input_rotate_6

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
stats->current_block_type=6;
userInput(get_signal(SPACE_KEY));
ck_assert_int_eq(stats->state, MOVING);

#test user_input_rotate_7

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
stats->current_block_type=7;
userInput(get_signal(SPACE_KEY));
ck_assert_int_eq(stats->state, MOVING);

#test user_input_gameover_1

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
stats->state=GAMEOVER;
userInput(NOSIG);
ck_assert_int_eq(stats->state, START);

#test user_input_collide_1

GameInfo_t *stats = updateCurrentState();
stats_init();
userInput(get_signal(ENTER_KEY));
for (int i = 0; i<20; i++){
  for (int j = 0; j<20; j++){
    stats->field[i][j]=1;
  }
}
block_init(1, stats->current_block_pos);
userInput(get_signal(KEY_DOWN));
ck_assert_int_eq(stats->state, SPAWN);